package domala.jdbc.query

import java.lang.reflect.Method

import domala.jdbc.entity.{EntityDesc, EntityPropertyDesc}
import org.seasar.doma.internal.expr.Value
import org.seasar.doma.internal.jdbc.entity._
import org.seasar.doma.internal.jdbc.sql.SqlContext
import org.seasar.doma.internal.jdbc.sql.node.{ExpandNode, PopulateNode}
import org.seasar.doma.internal.util.AssertionUtil
import org.seasar.doma.internal.util.AssertionUtil.assertNotNull
import org.seasar.doma.jdbc._
import org.seasar.doma.jdbc.query.{AbstractQuery, ModifyQuery, UpdateQueryHelper}

abstract class AbstractSqlModifyQuery(protected val kind: SqlKind) extends AbstractQuery with ModifyQuery {
  protected val EMPTY_STRINGS = new Array[String](0)
  protected val parameters: java.util.Map[String, Value] = new java.util.LinkedHashMap[String, Value]()
  protected var sql: PreparedSql = _
  protected var optimisticLockCheckRequired: Boolean = false
  private var executable = false
  private var sqlExecutionSkipCause = SqlExecutionSkipCause.STATE_UNCHANGED
  protected var sqlLogType: SqlLogType = _
  protected var includedPropertyNames: Array[String] = EMPTY_STRINGS
  protected var excludedPropertyNames: Array[String] = EMPTY_STRINGS

  AssertionUtil.assertNotNull(kind, "")

  protected def prepareOptions(): Unit = {
    if (this.queryTimeout <= 0) this.queryTimeout = this.config.getQueryTimeout
  }

  protected def expandColumns(node: ExpandNode): java.util.List[String] = throw new UnsupportedOperationException

  protected def populateValues(node: PopulateNode, context: SqlContext): Unit = throw new UnsupportedOperationException

  override def complete(): Unit = ()

  def addParameter(name: String, `type`: Class[_], value: Any): Unit = {
    AssertionUtil.assertNotNull(name, `type`)
    this.parameters.put(name, new Value(`type`, value))
  }

  def clearParameters(): Unit = {
    this.parameters.clear()
  }

  def setSqlLogType(sqlLogType: SqlLogType): Unit = {
    this.sqlLogType = sqlLogType
  }

  def setIncludedPropertyNames(includedPropertyNames: String*): Unit = {
    this.includedPropertyNames = includedPropertyNames.toArray
  }

  def setExcludedPropertyNames(excludedPropertyNames: String*): Unit = {
    this.excludedPropertyNames = excludedPropertyNames.toArray
  }

  override def getSql: PreparedSql = this.sql

  override def isOptimisticLockCheckRequired: Boolean = this.optimisticLockCheckRequired

  override def isExecutable: Boolean = this.executable

  override def getSqlExecutionSkipCause: SqlExecutionSkipCause = this.sqlExecutionSkipCause

  override def isAutoGeneratedKeysSupported: Boolean = false

  override def getSqlLogType: SqlLogType = this.sqlLogType

  override def toString: String = if (this.sql != null) this.sql.toString else null

  protected def setExecutable(): Unit = {
    this.executable = true
    this.sqlExecutionSkipCause = null
  }

  protected class InsertEntityHandler[E](
    name: String,
    var entity: E,
    entityName: EntityDesc[E]) {
    assertNotNull(name, entity, entityName)

    def preInsert(): Unit = {
      val context = new SqlPreInsertContext(entityName, method, config)
      entityName.preInsert(entity, context)
      if (context.getNewEntity != null) {
        entity = context.getNewEntity
        addParameter(name, entityName.getEntityClass, entity)
      }
    }

    def postInsert(): Unit = {
      val context = new SqlPostInsertContext(entityName, method, config)
      entityName.postInsert(entity, context)
      if (context.getNewEntity != null) entity = context.getNewEntity
    }
  }

  protected class SqlPreInsertContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPreInsertContext[E](entityDesc, method, config)

  protected class SqlPostInsertContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPostInsertContext[E](entityDesc, method, config)


  protected class UpdateEntityHandler[E](
    name: String,
    var entity: E,
    entityDesc: EntityDesc[E],
    nullExcluded: Boolean,
    versionIgnored: Boolean,
    optimisticLockExceptionSuppressed: Boolean) {
    assertNotNull(name, entity, entityDesc)
    private val versionPropertyType = entityDesc.getVersionPropertyType
    protected var targetPropertyTypes: java.util.List[EntityPropertyDesc[E, _]] = _
    protected var helper: UpdateQueryHelper[E] = _

    import org.seasar.doma.jdbc.query.UpdateQueryHelper

    def init(): Unit = {
      helper = new UpdateQueryHelper[E](config, entityDesc, includedPropertyNames, excludedPropertyNames, nullExcluded, versionIgnored, optimisticLockExceptionSuppressed, false)
    }

    def preUpdate(): Unit = {
      val context = new SqlPreUpdateContext(entityDesc, method, config)
      entityDesc.preUpdate(entity, context)
      if (context.getNewEntity != null) {
        entity = context.getNewEntity
        addParameter(name, entityDesc.getEntityClass, entity)
      }
    }

    def prepareTargetPropertyTypes(): Unit = {
      targetPropertyTypes = helper.getTargetPropertyTypes(entity)
    }

    def hasTargetPropertyTypes: Boolean = targetPropertyTypes != null && !targetPropertyTypes.isEmpty

    def postUpdate(): Unit = {
      val context = new SqlPostUpdateContext(entityDesc, method, config)
      entityDesc.postUpdate(entity, context)
      if (context.getNewEntity != null) entity = context.getNewEntity
      entityDesc.saveCurrentStates(entity)
    }

    def prepareOptimisticLock(): Unit = {
      if (versionPropertyType != null && !versionIgnored) if (!optimisticLockExceptionSuppressed) optimisticLockCheckRequired = true
    }

    def incrementVersion(): Unit = {
      if (versionPropertyType != null && !versionIgnored) entity = versionPropertyType.increment(entityDesc, entity)
    }

    def populateValues(context: SqlContext): Unit = {
      helper.populateValues(entity, targetPropertyTypes, versionPropertyType, context)
    }
  }

  protected class SqlPreUpdateContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPreUpdateContext[E](entityDesc, method, config) {
    override def isEntityChanged: Boolean = true
    override def isPropertyChanged(propertyName: String): Boolean = {
      validatePropertyDefined(propertyName)
      true
    }
  }

  protected class SqlPostUpdateContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPostUpdateContext[E](entityDesc, method, config) {
    override def isPropertyChanged(propertyName: String): Boolean = {
      validatePropertyDefined(propertyName)
      true
    }
  }

  protected class EntityHandler[E](
    name: String,
    var entity: E,
    entityDesc: EntityDesc[E],
    versionIgnored: Boolean,
    optimisticLockExceptionSuppressed: Boolean) {
    assertNotNull(name, entity, entityDesc)
    private val versionPropertyType = entityDesc.getVersionPropertyType
    def preDelete(): Unit = {
      val context = new SqlPreDeleteContext(entityDesc, method, config)
      entityDesc.preDelete(entity, context)
      if (context.getNewEntity != null) {
        entity = context.getNewEntity
        addParameter(name, entityDesc.getEntityClass, entity)
      }
    }

    def postDelete(): Unit = {
      val context = new SqlPostDeleteContext(entityDesc, method, config)
      entityDesc.postDelete(entity, context)
      if (context.getNewEntity != null) entity = context.getNewEntity
    }

    def prepareOptimisticLock(): Unit = {
      if (versionPropertyType != null && !versionIgnored) if (!optimisticLockExceptionSuppressed) optimisticLockCheckRequired = true
    }
  }

  protected class SqlPreDeleteContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPreDeleteContext[E](entityDesc, method, config)

  protected class SqlPostDeleteContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPostDeleteContext[E](entityDesc, method, config)

}
