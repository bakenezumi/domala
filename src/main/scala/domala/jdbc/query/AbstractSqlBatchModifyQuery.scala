package domala.jdbc.query

import java.lang.reflect.Method

import domala.jdbc.entity.EntityDesc
import org.seasar.doma.internal.jdbc.entity._
import org.seasar.doma.internal.jdbc.sql.SqlContext
import org.seasar.doma.internal.jdbc.sql.node.{ExpandNode, PopulateNode}
import org.seasar.doma.internal.util.AssertionUtil
import org.seasar.doma.internal.util.AssertionUtil.assertNotNull
import org.seasar.doma.jdbc._
import org.seasar.doma.jdbc.query.{AbstractQuery, BatchModifyQuery}

abstract class AbstractSqlBatchModifyQuery[ELEMENT](
  protected val elementClass: Class[ELEMENT],
  protected val kind: SqlKind) extends AbstractQuery with BatchModifyQuery {
  protected val EMPTY_STRINGS = new Array[String](0)
  protected var parameterName: String = _

  protected var optimisticLockCheckRequired: Boolean = false
  private var executable = false
  private var sqlExecutionSkipCause = SqlExecutionSkipCause.BATCH_TARGET_NONEXISTENT
  protected var batchSize: Int = 0
  protected var sqlLogType: SqlLogType = _
  protected var includedPropertyNames: Array[String] = EMPTY_STRINGS
  protected var excludedPropertyNames: Array[String] = EMPTY_STRINGS
  protected var elements: java.util.List[ELEMENT] = _
  protected var currentEntity: ELEMENT = _
  protected var sqls: java.util.List[PreparedSql] = _

  AssertionUtil.assertNotNull(kind, "")

  override def prepare(): Unit = {
    super.prepare()
    AssertionUtil.assertNotNull(method, parameterName, elements, sqls, "", "")
  }

  protected def prepareOptions(): Unit = {
    if (this.queryTimeout <= 0) this.queryTimeout = this.config.getQueryTimeout
    if (this.batchSize <= 0) this.batchSize = this.config.getBatchSize
  }


  protected def expandColumns(node: ExpandNode): java.util.List[String] = throw new UnsupportedOperationException

  protected def populateValues(node: PopulateNode, context: SqlContext): Unit = throw new UnsupportedOperationException

  def setParameterName(parameterName: String): Unit = {
    this.parameterName = parameterName
  }

  import java.util

  import org.seasar.doma.jdbc.PreparedSql

  def setElements(elements: Iterable[ELEMENT]): Unit = {
    AssertionUtil.assertNotNull(elements, "")
    if (elements.isInstanceOf[util.Collection[_]]) this.elements = new java.util.ArrayList[ELEMENT](elements.asInstanceOf[java.util.Collection[ELEMENT]])
    else {
      this.elements = new java.util.ArrayList[ELEMENT]
      for (element <- elements) {
        this.elements.add(element)
      }
    }
    this.sqls = new java.util.ArrayList[PreparedSql](this.elements.size)
  }

  def getEntities: java.util.List[ELEMENT] = elements

  def setBatchSize(batchSize: Int): Unit = {
    this.batchSize = batchSize
  }

  def setSqlLogType(sqlLogType: SqlLogType): Unit = {
    this.sqlLogType = sqlLogType
  }

  def setIncludedPropertyNames(includedPropertyNames: String*): Unit = {
    this.includedPropertyNames = includedPropertyNames.toArray
  }

  def setExcludedPropertyNames(excludedPropertyNames: String*): Unit = {
    this.excludedPropertyNames = excludedPropertyNames.toArray
  }

  override def getSql: PreparedSql = this.sqls.get(0)

  override def getSqls: java.util.List[PreparedSql] = this.sqls

  override def getConfig: Config = this.config

  override def isOptimisticLockCheckRequired: Boolean = this.optimisticLockCheckRequired

  override def isAutoGeneratedKeysSupported: Boolean = false

  override def isExecutable: Boolean = executable

  override def getSqlExecutionSkipCause: SqlExecutionSkipCause = this.sqlExecutionSkipCause

  override def getBatchSize: Int = batchSize

  override def getSqlLogType: SqlLogType = this.sqlLogType

  override def toString: String = sqls.toString

  protected def setExecutable(): Unit = {
    this.executable = true
    this.sqlExecutionSkipCause = null
  }

  protected class BatchInsertEntityHandler(var entityDesc: EntityDesc[ELEMENT]) {
    assertNotNull(entityDesc, "")

    def preInsert(): Unit = {
      val context = new SqlBatchPreInsertContext[ELEMENT](entityDesc, method, config)
      entityDesc.preInsert(currentEntity, context)
      if (context.getNewEntity != null) currentEntity = context.getNewEntity
    }

    def postInsert(): Unit = {
      val context = new SqlBatchPostInsertContext[ELEMENT](entityDesc, method, config)
      entityDesc.postInsert(currentEntity, context)
      if (context.getNewEntity != null) currentEntity = context.getNewEntity
    }
  }

  protected class SqlBatchPreInsertContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPreInsertContext[E](entityDesc, method, config) {}

  protected class SqlBatchPostInsertContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPostInsertContext[E](entityDesc, method, config) {}

  protected class BatchUpdateEntityHandler(
    entityDesc: EntityDesc[ELEMENT],
    versionIgnored: Boolean,
    optimisticLockExceptionSuppressed: Boolean) {
    import org.seasar.doma.jdbc.entity.EntityPropertyType
    import org.seasar.doma.jdbc.query.BatchUpdateQueryHelper

    assertNotNull(entityDesc, "")

    private val versionPropertyType = entityDesc.getVersionPropertyType
    protected var targetPropertyTypes: java.util.List[EntityPropertyType[ELEMENT, _]] = _
    protected var helper: BatchUpdateQueryHelper[ELEMENT] = _

    def init(): Unit = {
      helper = new BatchUpdateQueryHelper[ELEMENT](config, entityDesc, includedPropertyNames, excludedPropertyNames, versionIgnored, optimisticLockExceptionSuppressed)
    }

    def preUpdate(): Unit = {
      val context = new SqlBatchPreUpdateContext[ELEMENT](entityDesc, method, config)
      entityDesc.preUpdate(currentEntity, context)
      if (context.getNewEntity != null) currentEntity = context.getNewEntity
    }

    def prepareTargetPropertyTypes(): Unit = {
      targetPropertyTypes = helper.getTargetPropertyTypes
    }

    def postUpdate(): Unit = {
      val context = new SqlBatchPostUpdateContext[ELEMENT](entityDesc, method, config)
      entityDesc.postUpdate(currentEntity, context)
      if (context.getNewEntity != null) currentEntity = context.getNewEntity
    }

    import org.seasar.doma.internal.jdbc.sql.SqlContext

    def prepareOptimisticLock(): Unit = {
      if (versionPropertyType != null && !versionIgnored) if (!optimisticLockExceptionSuppressed) optimisticLockCheckRequired = true
    }

    def incrementVersions(): Unit = {
      if (versionPropertyType != null && !versionIgnored) {
        val it = elements.listIterator
        while ( {it.hasNext}) {
          val newEntity = versionPropertyType.increment(entityDesc, it.next)
          it.set(newEntity)
        }
      }
    }

    def populateValues(context: SqlContext): Unit = {
      helper.populateValues(currentEntity, targetPropertyTypes, versionPropertyType, context)
    }
  }

  protected class SqlBatchPreUpdateContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPreUpdateContext[E](entityDesc, method, config) {
    override def isEntityChanged: Boolean = true
    override def isPropertyChanged(propertyName: String): Boolean = {
      validatePropertyDefined(propertyName)
      true
    }
  }

  protected class SqlBatchPostUpdateContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPostUpdateContext[E](entityDesc, method, config) {
    override def isPropertyChanged(propertyName: String): Boolean = {
      validatePropertyDefined(propertyName)
      true
    }
  }

  protected class BatchDeleteEntityHandler(
    entityDesc: EntityDesc[ELEMENT],
    versionIgnored: Boolean,
    optimisticLockExceptionSuppressed: Boolean) {
    assertNotNull(entityDesc, "")

    private val versionPropertyType = entityDesc.getVersionPropertyType

    def preDelete(): Unit = {
      val context = new SqlBatchPreDeleteContext[ELEMENT](entityDesc, method, config)
      entityDesc.preDelete(currentEntity, context)
      if (context.getNewEntity != null) currentEntity = context.getNewEntity
    }

    def postDelete(): Unit = {
      val context = new SqlBatchPostDeleteContext[ELEMENT](entityDesc, method, config)
      entityDesc.postDelete(currentEntity, context)
      if (context.getNewEntity != null) currentEntity = context.getNewEntity
    }

    def prepareOptimisticLock(): Unit = {
      if (versionPropertyType != null && !versionIgnored) if (!optimisticLockExceptionSuppressed) optimisticLockCheckRequired = true
    }
  }

  protected class SqlBatchPreDeleteContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPreDeleteContext[E](entityDesc, method, config) {}

  protected class SqlBatchPostDeleteContext[E](entityDesc: EntityDesc[E], method: Method, config: Config) extends AbstractPostDeleteContext[E](entityDesc, method, config) {}
}
