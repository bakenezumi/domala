package domala.jdbc.query

import domala.internal.expr.ExpressionEvaluator
import domala.internal.jdbc.sql.NodePreparedSqlBuilder
import org.seasar.doma.internal.expr.Value
import org.seasar.doma.internal.jdbc.sql.{SqlContext, SqlParser}
import org.seasar.doma.internal.jdbc.sql.node.{ExpandNode, PopulateNode}
import org.seasar.doma.internal.util.AssertionUtil
import org.seasar.doma.jdbc._
import org.seasar.doma.jdbc.query.{AbstractQuery, ModifyQuery}

class SqlAnnotationModifyQuery(protected val kind: SqlKind, sqlString: String) extends AbstractQuery with ModifyQuery {

  protected val EMPTY_STRINGS = new Array[String](0)
  protected val sqlNode: SqlNode = this.config match {
    case domalaConfig: domala.jdbc.Config => domalaConfig.getSqlNodeRepository.get(sqlString)
    case _ => new SqlParser(sqlString).parse()
  }
  protected val parameters: java.util.Map[String, Value] = new java.util.LinkedHashMap[String, Value]()
  protected var sql: PreparedSql = _
  protected var optimisticLockCheckRequired: Boolean = false
  private var executable = false
  private var sqlExecutionSkipCause = SqlExecutionSkipCause.STATE_UNCHANGED
  protected var sqlLogType: SqlLogType = _
  protected var includedPropertyNames: Array[String] = EMPTY_STRINGS
  protected var excludedPropertyNames: Array[String] = EMPTY_STRINGS

  AssertionUtil.assertNotNull(kind, "")

  protected def prepareOptions(): Unit = {
    if (this.queryTimeout <= 0) this.queryTimeout = this.config.getQueryTimeout
  }

  protected def prepareSql(): Unit = {
    val evaluator = new ExpressionEvaluator(this.parameters, this.config.getDialect.getExpressionFunctions, this.config.getClassHelper)
    val sqlBuilder = new NodePreparedSqlBuilder(this.config, this.kind, evaluator, this.sqlLogType, this.expandColumns _, this.populateValues _)
    this.sql = sqlBuilder.build(this.sqlNode, this.comment _)
  }

  protected def expandColumns(node: ExpandNode): java.util.List[String] = throw new UnsupportedOperationException

  protected def populateValues(node: PopulateNode, context: SqlContext): Unit = throw new UnsupportedOperationException

  override def complete(): Unit = ()

  def addParameter(name: String, `type`: Class[_], value: Any): Unit = {
    AssertionUtil.assertNotNull(name, `type`)
    this.parameters.put(name, new Value(`type`, value))
  }

  def clearParameters(): Unit = {
    this.parameters.clear()
  }

  def setSqlLogType(sqlLogType: SqlLogType): Unit = {
    this.sqlLogType = sqlLogType
  }

  def setIncludedPropertyNames(includedPropertyNames: String*): Unit = {
    this.includedPropertyNames = includedPropertyNames.toArray
  }

  def setExcludedPropertyNames(excludedPropertyNames: String*): Unit = {
    this.excludedPropertyNames = excludedPropertyNames.toArray
  }

  override def getSql: PreparedSql = this.sql

  override def isOptimisticLockCheckRequired: Boolean = this.optimisticLockCheckRequired

  override def isExecutable: Boolean = this.executable

  override def getSqlExecutionSkipCause: SqlExecutionSkipCause = this.sqlExecutionSkipCause

  override def isAutoGeneratedKeysSupported: Boolean = false

  override def getSqlLogType: SqlLogType = this.sqlLogType

  override def toString: String = if (this.sql != null) this.sql.toString else null

  protected def setExecutable(): Unit = {
    this.executable = true
    this.sqlExecutionSkipCause = null
  }
}
